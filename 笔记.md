- 为了不让每次更新组件都刷新页面，配置热加载

  - yarn add react-hot-loader --dev
  - 在 webpack.config.js 370 行 babel-loader 添加

  ```javascript
  plugins: [
    [
      require.resolve('babel-plugin-named-asset-import'),
      {
        loaderMap: {
          svg: {
            ReactComponent: '@svgr/webpack?-svgo,+titleProp,+ref![path]'
          }
        }
      },
      'react-hot-loader/babel' // 这里是添加的行
    ]
  ]
  ```

  - 在需要用到热加载的组件 引入 hot `import { hot } from 'react-hot-loader'`
  - 最后到处经过 hot 函数高阶后的组件 `export default hot(module)(Component)`

- 使用 react-transition-group 实现过度效果

  - 安装 yarn add react-transition-group

  - 引入 `import { CSSTransition } from 'react-transition-group'`

  - 使用 ```typescript
    <CSSTransition
            in={this.state.in}
            timeout={2000}
            unmountOnExit
            classNames='filter-box'>

      <ul className='filter-box'>
      <li>全部课程</li>
      <li>react 课程</li>
      <li>Vue 课程</li>
      <li> 小程序课程</li>
      </ul>
    </CSSTransition>

        ```

  - CSSTransition 是一个持续的动画，因为我通过 `in` 控制列表的隐藏和现实，所以在配置上加入了
    `unmountOnExit`
  - CSSTransition 通过包裹同类名元素，为该元素添加过度效果，在过度进行和结束期间添加不同的类名以达到动画的过度，而控制组件的显示和隐藏是通过操作组件的状态

- 使用 Axios 响应拦截器返回的响应主体,即只返回服务器响应成功后的 data 内容

  - 在 axios 设置拦截器

  ```typescript
  axios.interceptors.response.use((result: AxiosRequestConfig) => result.data)
  ```

  - 在发送请求的函数显式告诉拦截后返回内容的格式

  ```typescript
  interface LoginResponse {
    code: number
    msg?: string
  }

  // 验证是否登录
  export function checkLogin(): Promise<LoginResponse> {
    return axios.get('/personal/login')
  }
  ```

- 权限校验
  - 路由的验证和渲染是同步的,不允许在校验中出现异步,因为这样在异步没有完成之前,根本不知道该渲染谁,语法不支持这样操作
  - 下面代码的操作方式是不允许的
    ```typescript
    <Route
      path='/person/info'
      render={async () => {
        // 验证是否登录的权限校验,权限校验的是同步的
        let result = await checkLogin()
        if (result.code === 0) {
          return <Info />
        }
        return <Tip />
      }}
    />
    ```
